import SwiftySites

let doccNetlifyPost = TaggedPost("/posts/docc-netlify", "DocC and Netlify", "dl", "2021-09-08T12:00:00Z", ["Netlify", "DocC"]) { """

On a [previous post](/posts/docc-website) I discussed how to merge a DocC documentation archive into a SwiftySites-generated website.

Now Apple provides [some guidelines](https://developer.apple.com/documentation/Xcode/distributing-documentation-to-external-developers) on how to make the exported site play nice with your web server using [rewrites](https://httpd.apache.org/docs/2.4/rewrite/intro.html).

But with static sites it is common not to have such control over the server side. We instead prefer services like [GitHub Pages](https://pages.github.com) and [Netlify](https://www.netlify.com) which is the one used by this page.

There is already a [great write-up](https://josephduffy.co.uk/posts/hosting-docc-archives) on how to integrate DocC with Netlify. I had to make a few tweaks here and there but the solution pretty much worked seamessly.

Finally here's the resulting configuration used to host SwiftySites's own [DocC documentation](/documentation/).

<figcaption>netlify.toml</figcaption>

```toml
[[redirects]]
from = "/documentation/*"
status = 200
to = "/SwiftySites.doccarchive/index.html"

[[redirects]]
from = "/tutorials/*"
status = 200
to = "/SwiftySites.doccarchive/index.html"

[[redirects]]
from = "/data/documentation.json"
status = 200
to = "/SwiftySites.doccarchive/data/documentation/root.json"

[[redirects]]
from = "/css/*"
status = 200
to = "/SwiftySites.doccarchive/css/:splat"

[[redirects]]
from = "/data/*"
status = 200
to = "/SwiftySites.doccarchive/data/:splat"

[[redirects]]
from = "/downloads/*"
status = 200
to = "/SwiftySites.doccarchive/downloads/:splat"

[[redirects]]
from = "/images/*"
status = 200
to = "/SwiftySites.doccarchive/images/:splat"

[[redirects]]
from = "/img/*"
status = 200
to = "/SwiftySites.doccarchive/img/:splat"

[[redirects]]
from = "/index/*"
status = 200
to = "/SwiftySites.doccarchive/index/:splat"

[[redirects]]
from = "/js/*"
status = 200
to = "/SwiftySites.doccarchive/js/:splat"

[[redirects]]
from = "/videos/*"
status = 200
to = "/SwiftySites.doccarchive/videos/:splat"

[[redirects]]
from = "/metadata.json"
status = 200
to = "/SwiftySites.doccarchive/metadata.json"

[[redirects]]
from = "/theme-settings.json"
status = 200
to = "/SwiftySites.doccarchive/theme-settings.json"

""" }

let themeSwitchPost = TaggedPost("/posts/theme-switch", "Theme Switch", "dl", "2021-09-07T12:00:00Z", ["Theme-Switch", "Javascript", "Web-Standards", "DocC"]) { """

The websites generated by Apple's DocC tool all feature this very handy toggle for switching between dark and light themes. In a [previous post](/posts/docc-website) the idea of merging a SwiftySites blog with a DocC web archive was introduced. Wouldn't it be nice to have that same theme-switching control on _all_ pages?

Introducing [Theme Switch](https://github.com/swiftysites/theme-switch) by SwiftySites. Theme Switch is a web component that replicates both the look and behaviour of Apple's control with some additional features.

![Theme Switch](/assets/theme-switch.gif)

Unlike the DocC toggle which is implemented using [Vue.js](https://vuejs.org), Theme Switch does not have any dependencies and instead is implemented with pure Javascript as a standard [v1 HTML Custom Element](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements).

It allows you to define your own dark mode CSS and display it only when your users wish it. When in automatic mode it will honor the system's preference. And if your browser does not support CSS [color scheme preferences](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme) the component will just let the user pick between the two options.

Try it out on your own websites or better yet try it on your SwiftySites website!

""" }

let doccPost = TaggedPost("/posts/docc-website", "DocC Website", "dl", "2021-09-06T12:00:00Z", ["DocC", "Web-Standards"]) { #"""

This site has two functions. One is to be a real-world test of the SwiftySites framework – documenting its evolution. The other is the more traditional role of hosting the tool's documentation.

The [DocC Framework](https://developer.apple.com/documentation/docc) is brand new but a fills up a gap previously covered by [open-source efforts](https://swiftdoc.org). Since SwiftySites is also new I thought it would be the perfect fit to try out the officially sanctioned way of generating docs.

In a way DocC is its own static site generator not unlike SwiftySites. It uses comments on the source code as well as standalone Markdown files as input and it applies internal HTML templates to produce a website. So the challenge becomes how to merge the DocC-generated site into this present site.

Apple has a [guide](https://developer.apple.com/documentation/Xcode/distributing-documentation-to-external-developers) which includes how to _Host a Documentation Archive on Your Website_. It simply involves exporting the generated bundle from the Xcode viewer.

My solution was to straightforwardly dump the exported DocC archive into the `static` folder of this very site's [source repo](https://github.com/swiftysites/website/tree/develop/static). SwiftySites will copy all static contents and only then generate the new outputs on top so we only need to be careful not to call things with the same name.

The final result can be seen [here](/documentation/) in all its glory.

"""# }

let syntaxHightlightingPost = TaggedPost("/posts/syntax-highlighting", "Syntax Highlighting", "dl", "2021-09-05T12:00:00Z", ["Javascript", "Markdown"]) { #"""

After overcomming the first big challenge of implementing [Markdown support](/posts/supporting-markdown) I found out rather quickly that this did not include any type of syntax hightlighting.

All `pre` blocks were rendered with no color and the code block [info string](https://github.github.com/gfm/#info-string) was largely ignored by my basic stylesheet.

Once again I turned to Apple and noticed they were using [highlight.js](https://highlightjs.org) to generate the code blocks used in [DocC](https://developer.apple.com/documentation/docc).

I decided to [customize](https://highlightjs.org/download/) my download to include only the languages I would need for this blog. I also picked one of the many color schemes they have available.

To put it to the test what better way than including a chunk of the code used to generate this exact page with SwiftySites. Lo and behold the coloring magically appears.

<figcaption>main.js</figcaption>

```swift
let homePage = Page("Home Page", path: "/") { """
_Some markdown here…_
"""

let pageTemplate = BasicSite.templateA { site, page in """
<!doctype html>
<html lang="en">
    …
    <title>\(site.title)</title>
    …
    <main>\(page.content)</main>
    …
</html>
""" }

BasicSite(
    SiteConfig(title: "SwiftySites"),
    contentA: [homePage],
    templates: [pageTemplate]
).render()
```

Now having inspected a DocC-generated site I have noticed that Apple is using a custom language definition for `highlight.js`. Since the code is obfuscated I couldn't extract it to incorporate into this site. Still the default Swift definition is decent enough and all of the other languages render nicely.

"""# }

let supportingMarkdownPost = TaggedPost("/posts/supporting-markdown", "Supporting Markdown", "dl", "2021-09-04T12:00:00Z", ["Markdown", "Swift"]) { #"""

One of the first challenges one encounters when building a static site generator is Markdown support.

I knew Apple had just [announced](https://developer.apple.com/videos/play/wwdc2021/10109/?time=486) during WWDC21 support for Markdown in attributed strings and other APIs but offered no interface for directly converting Markdown to HTML.

A bit of digging in the developer forums led me to [this answer](https://developer.apple.com/forums/thread/682711) by an Apple engineer. Now I knew for a fact that internally they were using the fantastic [cmark-gfm](https://github.com/github/cmark-gfm) library.

`cmark-gfm` itself is a fork of the [cmark](https://github.com/commonmark/cmark) C library. GFM stands for [GitHub Flavor Markdown](https://github.github.com/gfm/) and consists of a set of extensions to the [CommonMark](https://commonmark.org) specification.

Having some experience in integrating C code into Swift applications I started adapting `cmark-gfm` for my purposes. The endeavour involved cross-compiling for the relevant architectures and linking to a custom Objective-C framework.

Since `cmark-gfm` lacked a simplified interface for straightforwardly converting GFM to HTML – which the original `cmark` had – I decided to write my own Swift protocol around it. I decided to expose all the options and extensions available from the underlying libraries.

While the whole effort was [open-source](https://github.com/swiftysites/cmark-gfm) I decided to publish the final result as a binary XCFramework. This makes it really easy to include – via Swift Package Manager (SPM) – in SwiftySites or any other project that needs it without the hassle of having to build everything from C sources.

"""# }

let helloWorldPost = TaggedPost("/posts/hello-world", "Hello, World!", "dl", "2021-09-03T12:00:00Z", ["Swift", "Markdown", "Web-Standards"]) { #"""

Hello and welcome to the humble SwiftySites Blog. As a first post I thought it would be nice to share some of my motivation for building this library.

Nowadays it's pretty common for a programmer to want to show their work and process to the world. It's also common for us to write our own tools.

In the past I had used everything from traditional content management systems to popular [publishing platforms](https://medium.com/swift-you-and-i). For the past few years I settled for the awesome [Hugo](https://gohugo.io) static site generator which I used to build the original [Swift You and I](https://swiftui.diegolavalle.com) publication.

Hugo has a lot of amazing features which I love but it dows require some knowledge of the Go Language for writing the more advanced [templates](https://pkg.go.dev/text/template). For a long time I tried my best to learn but never felt as at home as I do when I write Swift.

Looking for options I quiclky landed in John Sundell's tool [Publish](https://github.com/johnsundell/publish). To be perfectly honest this would have been the tool to choose from the beginnig – had it existed a couple of years back.

At this point I had gotten accustomed to many of the niceties of Hugo and wanted to keep some of them around. John's [DSL approach](https://www.swiftbysundell.com/articles/building-dsls-in-swift/) showed me that the Swift compiler can really be helpful when defining a website's structure so I came up with a hybrid concept.

Instead of declaring everything straight in Swift I decided to split the problem in two. For the content's metadata – which Hugo implements with [Front Matter](https://gohugo.io/content-management/front-matter/) – I would leverage the full power of Swift's type system. For the templates I thought of something else…

Swift already has a great templating solution called [string interpolation](https://www.hackingwithswift.com/read/0/5/string-interpolation). This was the last piece of the puzzle. From the first proof of concept I noticed how nicely the structured metadata merged with the more free string composition.

In the coming weeks I will use this very site to test the concept and document the process of building a framework that hopefully other people find useful.

Cheers!
"""# }

let dogfoodingPost = TaggedPost("/posts/supporting-markdown", "Supporting Markdown", "SwiftySites", "2021-08-15T12:00:00Z") { #"""



"""# }

let netlify = TaggedPost("/posts/netlify", "Supporting Markdown", "SwiftySites", "2021-08-15T12:00:00Z") { #"""



"""# }

let hugoPost = TaggedPost("/posts/swift-docker", "Docker", "SwiftySites", "2021-08-15T12:00:00Z") { #"""

With an admin user.

```sh
brew install docker docker-machine
brew install --cask virtualbox
```

Fix permisions on _System Preferences > Security & Privacy_ and restart.

With any user.

```sh
docker-machine create --driver virtualbox default
eval $(docker-machine env default)
docker pull swiftlang/swift:nightly-5.5-focal
mkdir swiftylinux
docker run -it -v "$PWD/swiftylinux":/swiftylinux --name swiftylinux swiftlang/swift:nightly-5.5-focal /bin/bash
exit
docker start swiftylinux
docker attach swiftylinux
docker rm swiftylinux
```

In Docker. For binary targets pointing to XCFramework zip archives install the `unzip` tool.

```sh
apt update
apt install unzip
```

"""# }
